# Root reinforcement models
# - Wu/Waldron model (Class "Wwm")
# - Fibre bundle model (Class "Fbm")
# - Root bundle model weibull (Class "Rbmw")

# import packages and functions
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from scipy.special import gamma
from scipy.optimize import minimize, differential_evolution
from pyrootmemo.tools.helpers import units
from pyrootmemo.geometry import SoilProfile, FailureSurface
from pyrootmemo.materials import MultipleRoots, Interface
from pyrootmemo.pullout import PulloutEmbeddedElastic, PulloutEmbeddedElasticSlipping, PulloutEmbeddedElasticBreakage, PulloutEmbeddedElasticBreakageSlipping, PulloutEmbeddedElastoplastic, PulloutEmbeddedElastoplasticSlipping, PulloutEmbeddedElastoplasticBreakage, PulloutEmbeddedElastoplasticBreakageSlipping
from pyrootmemo.tools.utils_rotation import axisangle_rotate
from pyrootmemo.tools.utils_plot import round_range
from pint import Quantity, DimensionalityError
import warnings


# FUNCTION #
import numpy as np
def make_quantity(
        values: int | float | list | np.ndarray | Quantity,
        unit: str
        ):
    if isinstance(values, Quantity):
        if values.dimensionality != units(unit).dimensionality:
            raise DimensionalityError('dimensionality of values does not match defined unit')
        else:
            return(values)
    elif isinstance(values, int) | isinstance(values, float):
        return(values * units(unit))
    elif isinstance(values, list):
        if all(isinstance(x, int) | isinstance(x, float) for x in values):
            return(np.array(values) * units(unit))
        else:
            return ValueError('all items in values must be int or float')
    elif isinstance(values, np.ndarray):
        if np.isnumeric(values):
            return(values * units(unit))
        else:
            return ValueError('all items in values must be numeric')
    else:
        TypeError('values must be int, float, list, ndarray or Quantity')



########################
### WU/WALDRON MODEL ###
########################


# WWM class
class Wwm():
    """
    Class for Wu/Waldron Model.
           
    The class constains some additional methods:
    * 'peak_force()': calculate peak force in root bundle (sum of strenghts)
    * 'peak_reinforcement()': calculate peak root reinforcement, given a known
      soil area and Wu/Waldron orientation factor 'k'
    
    """

    # initialise class
    def __init__(
            self, 
            roots: MultipleRoots,
            ) -> Wwm:
        """
        Creates a Wu/Waldron model object.

        Parameters
        ----------
        roots : MultipleRoots
            Contains information about all reinforcing roots, defined using the 
            MultipleRoots class.
            Class must contain attributes 'diameter', 'xsection', 'tensile_strength'

        """
        # check if MultipleRoots type
        if not isinstance(roots, MultipleRoots):
            TypeError('roots must be object of class MultipleRoots')
        # check if roots contains all required instances
        attributes_required = ['diameter', 'xsection', 'tensile_strength']
        for i in attributes_required:
            if not hasattr(roots, i):
                AttributeError('roots must contain ' + str(i) + ' attribute')
        # set roots as class parameters
        self.roots = roots

    # Calculate peak force 
    def peak_force(
            self
            ) -> Quantity:
        """
        Calculates WWM peak force.

        This is defined as the sum of the maximum tensile forces that can be mobilised in all roots
        """
        return(np.sum(self.roots.xsection * self.roots.tensile_strength))


    # reinforcement
    def peak_reinforcement(
            self, 
            failure_surface: FailureSurface,
            k: int | float = 1.2
            ) -> Quantity:
        """
        Calculate peak reinforcement (largest soil reinforcement at any point)
        generated by the fibre bundle

        Parameters
        ----------
        failure_surface : FailureSurface
            Instance of "FailureSurface" class. Must contain the attribute 
            "cross_sectional_area" that contains the cross-sectinonal area of the
            failure surface
        k : float, optional
            Wu/Waldron reinforcement orientation factor. The default is 1.2.

        Returns
        -------
        float
            peak root reinforcement.

        """
        # check cross-sectional area correctly defined
        if not isinstance(failure_surface, FailureSurface):
            TypeError('failure_surface must be intance of FailureSurface class')
        if not hasattr(failure_surface, 'cross_sectional_area'):
            AttributeError('failure_surface must contain attribute "cross_sectional_area"')
        # check k-factor
        if not (isinstance(k, int) | isinstance(k, float)):
            TypeError('k must be an scalar integer or float')
        # return
        return(k * self.peak_force() / failure_surface.cross_sectional_area)



##########################
### FIBRE BUNDLE MODEL ###
##########################


# FBM class
class Fbm():
    """
    Class for fibre bundle models.
    
    This class uses the "matrix" method as described in Yildiz & Meijer. This
    method follows the following steps:
    
    1. Roots are sorted in order of breakage. The 'sorting order', i.e. the 
       list of indices to sort root properties into the correct order, is 
       stored in class attribute 'sort_order'. The 'breakage order', i.e. the 
       list of indices describing the order of breakage for each root, is 
       stored in class attribute 'breakage_order'.
     
    2. A matrix is generated that calculates the force in every root (rows), 
       at the moment of breakage of any root (columns). This matrix is stored
       as the class attribute 'matrix', and assumes roots have already been 
       sorted in order of breakage
       
    3. Peak forces can now easily be termined by finding the column in the 
       matrix that has the largest sum of forces
       
       
    The class constains some additional methods:
    
    * 'peak_force()': calculate peak force in root bundle
    * 'peak_reinforcement()': calculate peak root reinforcement, given a known
      failure surface area and a Wu/Waldron orientation factor 'k'
    * 'plot()': (stack)plot showing how forces in each root are gradually 
      mobilised    
    
    """
    
    # initialise class
    def __init__(
            self, 
            roots: MultipleRoots, 
            load_sharing: float | int
            ):
        """
        Initiate fibre bundle model class

        Parameters
        ----------
        roots : instance of MultipleRoots class. 
            Must contain fields 'diameter', 'xsection' and 'tensile_strength'
        loadsharing : float
            fibre bundle model load sharing parameter.

        Returns
        -------
        None.

        """
        # check roots input
        if not isinstance(roots, MultipleRoots):
            TypeError('roots must be object of class MultipleRoots')
        attributes_required = ['diameter', 'xsection', 'tensile_strength']
        for i in attributes_required:
            if not hasattr(roots, i):
                raise AttributeError('roots must contain ' + str(i) + ' attribute')
        # check if loadsharing parameter is a finite, scalar value
        if not (isinstance(load_sharing, int) | isinstance(load_sharing, float)):
            raise ValueError('load_sharing must be a scalar integer or float')
        if np.isinf(load_sharing):
            raise ValueError('load_sharing must have finite value')
        # set parameters
        self.roots = roots
        self.load_sharing = load_sharing
        # get sorting order (get roots in order of failure
        self.sort_order = np.argsort(
            self._tensile_capacity() 
            / (roots.diameter ** load_sharing)
            )
        # get breakage order (order of root breakages
        self.breakage_order = np.argsort(self.sort_order)
        # get force matrix
        self.matrix = self._get_matrix()
        
        
    # tensile capacity - force at which roots break
    def _tensile_capacity(self) -> Quantity:
        """
        Calculate force at which each roots breaks
        """
        return(self.roots.tensile_strength * self.roots.xsection)
    
    
    # matrix  - matrix 
    def _get_matrix(self) -> Quantity:
        """
        Generate matrix for force in each root (rows) at breakage of each 
        root (columns). Assumes roots are sorted in order of breakage
        """
        # root capacity (force)
        force = self._tensile_capacity()
        # get units
        force_unit = force.units
        # sort data
        y_sorted = (force.magnitude)[self.sort_order]
        x_sorted = (self.roots.diameter.magnitude)[self.sort_order]
        # forces in each root (rows) as function of breaking root (columns)
        matrix = np.outer(
            x_sorted ** self.load_sharing,
            y_sorted / (x_sorted ** self.load_sharing)
            )
        # remove roots that have broken (upper triagle of matrix, so keep 
        # lower triangle)
        matrix_broken = np.tril(matrix)
        # return with units added back
        return(matrix_broken * force_unit)


    # peak force
    def peak_force(self) -> Quantity:
        """
        Calculate peak force (largest force at any point) in the fibre bundle

        Returns
        -------
        float
            peak force.

        """
        return(np.max(np.sum(self.matrix, axis = 0)))


    # reinforcement
    def peak_reinforcement(
            self, 
            failure_surface: FailureSurface,
            k: int | float = 1.0
            ) -> Quantity:
        """
        Calculate peak reinforcement (largest soil reinforcement at any point)
        generated by the fibre bundle

        Parameters
        ----------
        failure_surface : FailureSurface
            Instance of "FailureSurface" class. Must contain the attribute 
            "cross_sectional_area" that contains the cross-sectinonal area of the
            failure surface
        k : float, optional
            Wu/Waldron reinforcement orientation factor. The default is 1.0.

        Returns
        -------
        float
            peak root reinforcement.

        """
        # check cross-sectional area correctly defined
        if not isinstance(failure_surface, FailureSurface):
            raise TypeError('failure_surface must be intance of FailureSurface class')
        if not hasattr(failure_surface, 'cross_sectional_area'):
            raise AttributeError('Failure surface does not contain attribute cross_sectional_area')
        # check k-factor
        if not (isinstance(k, int) | isinstance(k, float)):
            TypeError('k must be an scalar integer or float')
        # return
        return(k * self.peak_force() / failure_surface.cross_sectional_area)
    
    # reduction factor
    def reduction_factor(self) -> float:
        """
        Calculate the ratio between bundle peak force and the sum of 
        individual fibre strengths. Function will thus return a value between
        0.0 and 1.0. '1.0' indicates all roots break simultaneously.

        Returns
        -------
        float
            reduction factor.

        """
        force_fbm = self.peak_force()
        force_sum = np.sum(self.roots.xsection * self.roots.tensile_strength)
        return((force_fbm / force_sum).magnitude)
    
    # plot how roots mobilise, according to FBM
    def plot(
            self,
            unit: str = 'N',
            reference_diameter: int | float | Quantity = 1.0,
            reference_diameter_unit: str = 'mm',
            stack: bool = False,
            peak: bool = True,
            labels: list | bool = False, 
            label_margin: float = 0.05, 
            xlabel: str = 'Force in reference root', 
            ylabel: str = 'Total force in root bundle'      
            ):
        """
        Generate a matplotlib plot showing how forces in each roots are 
        mobilised, as function of the force in the reference root

        Parameters
        ----------
        labels : bool, optional
            labels for individual roots, If False, no labels are plotted. If
            True, labels are plotted as numbers indicating the order in which
            roots are defined in the input. Can be defined as a list of 
            character strings to specify individual labels for each root.
            The default is True.
        label_margin : float, optional
            controls the location for plotting labels. Defined as the fraction
            of the x-axis size. Labels are plotted on the right-hand size of
            the force triangles, and centred vertically. The default is 0.05.
        xlabel : chr, optional
            x-axis label. The default is 'Force in reference root'.
        ylabel : chr, optional
            y-axis label. The default is 'Total force in root bundle'.

        Returns
        -------
        tuple
            Tuple containing a figure and an axis object.

        """
        # force matrix - force in each root (row) at breakage of each root (columns) - sorted
        M = self.matrix.to(unit).magnitude
        # diameters, normalised and sorted in order of breakage
        if isinstance(reference_diameter, Quantity):
            if reference_diameter.dimensionality != units('mm').dimensionality:
                raise DimensionalityError('dimensionality of reference_diameter must be length')
            if not np.isscalar(reference_diameter.magnitude):
                raise ValueError('reference diameter must be a scalar')
        elif isinstance(reference_diameter, int) | isinstance(reference_diameter, float):
            if 
            reference_diameter = reference_diameter * units(reference_diameter_unit) 
        diameter = self.roots.diameter.to(reference_diameter_unit).magnitude[self.sort_order]
        # force in reference root at moments of breakage, and just after
        x_before = np.diag(M) * (reference_diameter / diameter)**self.load_sharing
        x_after = x_before + 1.0e-12 * np.max(x_before)
        x_all = np.append(0.0, np.stack((x_before, x_after)).ravel(order = 'F'))
        # total reinforcement
        y_before = np.sum(M, axis = 0)
        y_after = y_before - np.diag(M)
        y_all = np.append(0.0, np.stack((y_before, y_after)).ravel(order = 'F'))
        # plot
        fig, ax = plt.subplots()
        if stack is True:
            # forces in individual roots
            y_before_i = M
            y_after_i = M - np.diag(np.diag(M))
            y_all_i = np.concatenate((
                np.zeros((M.shape[0], 1)),
                np.stack((y_before_i, y_after_i), axis = -1).reshape(M.shape[0], 2 * M.shape[1]),
                ), axis = -1)
            # reverse y-values (forces), so plot lines are stacked in order from last breaking to first breaking
            y_all_i = np.flip(y_all_i, axis = 0)
            # colour order - use default matplotlib colors, but order in which roots are defined
            prop_cycle = mpl.rcParams['axes.prop_cycle']
            colors = prop_cycle.by_key()['color']
            n_color = len(colors)
            colors_new = np.array(colors * int(np.ceil(M.shape[0] / n_color)))[np.flip(self.sort_order)]
            # plot stacked traces
            ax.stackplot(x_all, y_all_i, colors = colors_new)
            # plot total trace
            ax.plot(x_all, y_all, c = 'black')
            # label text
            if labels is True:
                labels = list(self.sort_order + 1)
                plot_labels = True
            elif isinstance(labels, list):
                if len(labels) == M.shape[0]:
                    labels = np.array(labels)[self.sort_order]
                    plot_labels = True
                else:
                    plot_labels = False
            else:
                plot_labels = False
            # add labels to plot
            if plot_labels is True:
                labels_x = x_before - label_margin * np.max(x_before)
                labels_y = (y_before - 0.5 * np.diag(M)) * labels_x / x_before
                for xi, yi, li in zip(labels_x, labels_y, labels):
                    ax.annotate(
                        li, xy = (xi, yi), 
                        ha = 'center', 
                        va = 'center', 
                        bbox = dict(boxstyle = 'round', fc = 'white', alpha = 0.5),
                        fontsize = 'small'
                        )
        else:
            # bundle force at moments of breakage, and just after
            y_before = np.sum(M, axis = 0)
            y_after = y_before - np.diag(M)
            # bundle force array for plotting
            y_all = np.append(0.0, np.stack((y_before, y_after)).ravel(order = 'F'))
            # plot
            ax.plot(x_all, y_all)
        # add peak reinforcement
        if peak is True:
            Msum0 = np.sum(M, axis = 0)
            i_peak = np.argmax(Msum0)
            x_peak = x_before[i_peak]
            y_peak = Msum0[i_peak]
            plt.scatter(x_peak, y_peak, c = 'black')
        # axes
        ax.set_xlabel(xlabel + " [" + unit + "]")
        ax.set_ylabel(ylabel + " [" + unit + "]")
        ax.set_xlim(round_range(x_all, limits = [0.0, None])['limits'])
        ax.set_ylim(round_range(
            self.peak_force().to(unit).magnitude, 
            limits = [0.0, None]
            )['limits'])
        # return plotted object
        return(fig, ax)



############
### RBMw ###
############


# RBMw class
class Rbmw():
    """
    Class for Root Bundle Model Weibull (RBMw).
           
    The class constains some additional methods:
    * 'force()': calculate the force in the root bundle at the current level of displacement
    * 'peak_force()': calculate peak force in root bundle
    * 'peak_reinforcement()': calculate peak root reinforcement, given a known
      soil area and Wu/Waldron orientation factor 'k'
    * 'plot()': plot showing how force changes as function of displacement
    
    """

    # initialise class
    def __init__(
            self, 
            roots: MultipleRoots,
            weibull_shape: float | int, 
            weibull_scale: float | int | None = None
            ) -> None:
        """
        Initiate RBMw bundle model class

        Parameters
        ----------
        roots : instance of MultipleRoots class. 
            Must contain fields 'xsection', 'tensile_strength', 
            'length', 'elastic_modulus'
        weibull_shape : float
            Weibull shape parameter (dimensionless)
        weibull_scale : float, optional
            Weibull scale parameter describing the (dimensionless) ratio 
            tensile stress/average strength (or tensile force/average force at 
            failure). Default is None, in which case it is calculated from the 
            Weibull shape parameter assuming an average ratio of 1.

        Returns
        -------
        None.

        """
        # check if roots of correct class
        if not isinstance(roots, MultipleRoots):
            TypeError('roots must be instance of class MultipleRoots')
        # check if roots contains all required instances
        attributes_required = ['xsection', 'tensile_strength', 'length', 'elastic_modulus']
        for i in attributes_required:
            if not hasattr(roots, i):
                AttributeError('roots must contain ' + i + ' values')
        # set roots
        self.roots = roots
        # check and set weibull shape parameter
        if not (isinstance(weibull_shape, float) | isinstance(weibull_shape, int)):
            ValueError('weibull_shape must be a scalar value')
        if weibull_shape <= 0.0:
            ValueError('weibull_shape must exceed zero ')
        if np.isinf(weibull_shape):
            ValueError('weibull_shape must have a finite value')
        self.weibull_shape = weibull_shape
        # calculate weibull scale parameter (if not already explicitly defined)
        if weibull_scale is None: 
            self.weibull_scale = 1. / gamma(1. + 1. / weibull_shape)
        else:
            if not (isinstance(weibull_scale, float) | isinstance(weibull_scale, int)):
                ValueError('weibull_scale must be a scalar value')
            if weibull_scale <= 0.0:
                ValueError('weibull_shape must exceed zero ')
            if np.isinf(weibull_scale):
                ValueError('weibull_shape must have a finite value')

    # forces in roots at current level of axial displacement
    def force(
            self,
            displacement: Quantity | int | float | np.ndarray,
            displacement_unit = 'm',
            total: bool = True,
            deriv: int = 0,
            sign: int | float = 1.0
            ) -> Quantity:
        """
        Calculate RBMw force at given displacement

        Parameters
        ----------
        displacement : Quantity
            Quantity object with displacements. Should have unit with dimension 
            length.
        total : bool, optional
            If True, return the total force of all roots. Otherwise, return
            results per displacement step (rows) for each root (columns)
        deriv : int, optional
            Differentiation order for displacement. If deriv == 1, the first
            derivatives of force with respect to displacement are returned. 
            If deriv == 2, return second-order derivative. Default is 0.
        sign : int, float, optional
            Multiplication factor for all result returned by the function. 
            This is used to be able to use minimisation algorithms in order
            to find the global maximum force, see function self.peak_force(). 
            Default = 1.0

        Returns
        -------
        Quantity object with (derivative of) forces.
        """
        # if displacement is not defined with a unit, make into a Quantity
        if isinstance(displacement, Quantity):
            if displacement.dimensionality != units('m').dimensionality:
                raise DimensionalityError('dimensionality of displacement must be length') 
        elif isinstance(displacement, int) | isinstance(displacement, float) | isinstance(displacement, np.ndarray):
            warnings.warn('Unit of displacement not defined. Assumed as ' + displacement_unit)
            displacement = displacement * units(displacement_unit)
        else:
            raise TypeError('displacement must be of type Quantity, float, int or np.ndarray')
        # if displacement is a scalar -> make a numpy array
        if np.isscalar(displacement.magnitude):
            displacement_scalar_input = True
            displacement = np.array([displacement.magnitude]) * displacement.units
        else:
            displacement_scalar_input = False
        # write force mobilisation curve in form: 
        #
        #   y = a*x*exp(-(x/b)^k)
        # 
        # using 2D arrays: First axis = displacement, second axis = roots
        a = (self.roots.elastic_modulus 
             * self.roots.xsection
             / self.roots.length)[np.newaxis, :]
        b = (self.roots.length
             * self.roots.tensile_strength
             / self.roots.elastic_modulus 
             * self.weibull_scale
            )[np.newaxis, :]
        x = displacement[:, np.newaxis]
        k = self.weibull_shape
        # force
        if deriv == 0:
            # calculate force per displacement step, per root
            y = a * x * np.exp(-(x / b) ** k)
            # return
            if total is True:
                if displacement_scalar_input is True:
                    return(sign * np.sum(y))
                else:
                    return(sign * np.sum(y, axis = 1))
            else:
                return(sign * y.squeeze())
        # derivative of force with respect to displacement
        elif deriv == 1:
            # calculate derivative of force with respect to dispalcement
            # per displacement step, per root
            dy_dx = (
                a * (1.0 - k * (x / b) ** k)
                * np.exp(-(x / b) ** k)
            )
            # return
            if total is True:
                if displacement_scalar_input is True:
                    return(sign * np.sum(dy_dx))
                else:
                    return(sign * np.sum(dy_dx, axis = 1))
            else:
                return(sign * dy_dx.squeeze())
        # second derivative of force with respect to displacement
        elif deriv == 2:
            # calculate 2nd derivative of force with respect to displacement
            # per displacement step, per root
            dy2_dx2 = (
                a * k / x
                * np.exp(-(x / b) ** k)
                * (x / b) ** k
                * (k * (x / b) ** k - k - 1.0)
                )
            # return
            if total is True:
                if displacement_scalar_input is True:
                    return(sign * np.sum(dy2_dx2))
                else:
                    return(sign * np.sum(dy2_dx2, axis = 1))
            else:
                return(sign * dy2_dx2.squeeze())


    # Calculate peak force 
    def peak_force(
            self,
            full_output: bool = False,
            method: str = 'Newton-CG'
            ) -> float | dict:
        """
        Calculate RBMw peak force

        The RBMw force--displacement trace may have multiple local maxima,
        making finding real maximum challenging. This function uses a root 
        solve method to find peaks, using multiple initial guesses.

        Initial guesses for peaks are determined by first finding the 
        displacements <u> where each single root reaches its maximum force. 
        Total bundle forces <F> at these locations are then calculated. 
        Subsequently, a guess is made of how large the force could become 
        in the interval to the next peak, using the force gradient at each 
        location <u>. Only locations where this potential force is larger 
        than the largest of forces in <F> are considered as initial guesses.
        This trims down the need for initial guesses and still ensures the
        global maximum is found.        

        Parameters
        ----------
        full_output : boolean, optional
            If False, returns the peak force only. If 'True', returns a 
            dictionary with fields 'force' and 'displacement' indicating
            the position of peak reinforcement in the force--displacement
            plot.
        method : str, optional
            Method to use in the scipy.optimize.minimize algorithm.
            Default is 'Newton-CG'. Analytical jacobian and hessian are 
            analytically known (see function self.force()).

        Returns
        -------
        Peak force (scalar), or dictionary with full results.
        """
        # displacements until peak reinforcement of each root
        displacements = (
            self.roots.tensile_strength / self.roots.elastic_modulus * self.roots.length
            / self.weibull_shape ** (1. / self.weibull_shape)
            * self.weibull_scale
        )
        displacements = np.sort(np.unique(displacements.magnitude)) * displacements.units
        # force and gradients at each peak
        forces = self.force(displacements, total = True).magnitude
        gradients = self.force(displacements, total = True, deriv = 1).magnitude
        # forwards predictions and max
        disp_diff = np.diff(displacements.magnitude)
        forces_forwards = np.append(forces[:-1] + disp_diff * gradients[:-1], 0.0)
        forces_max = np.maximum(forces, forces_forwards)
        # select which starting guesses to keep (max force that can be achieved from starting point must be larger than max from <forces> array)
        keep = (forces_max >= np.max(forces))
        # starting guesses for displacement at peak
        displacement_guesses = displacements[keep]
        # find displacement at peaks, for each of the starting guesses, using root solving
        unit = displacement_guesses.units
        fun = lambda x: self.force(x * unit, total = True, deriv = 0, sign = -1.0).magnitude
        jac = lambda x: self.force(x * unit, total = True, deriv = 1, sign = -1.0).magnitude
        hes = lambda x: self.force(x * unit, total = True, deriv = 2, sign = -1.0).magnitude
        displacement_options = np.concatenate([
            minimize(
                fun = fun,
                x0 = i.magnitude,
                jac = jac,
                hess = hes,
                method = method
            ).x
            for i in displacement_guesses
        ]) * unit
        # calculate forces at each displacement option (local peaks)
        peak_force_options = self.force(displacement_options, total = True)
        index = np.argmax(peak_force_options.magnitude)
        # return 
        if full_output is True:
            return({
                'force': peak_force_options[index],
                'displacement': displacement_options[index]    
            })
        else:
            return(peak_force_options[index])


    # reinforcement
    def peak_reinforcement(
            self, 
            failure_surface: FailureSurface,
            k: float = 1.0
            ) -> Quantity:
        """
        Calculate peak reinforcement (largest soil reinforcement at any point)
        generated by the fibre bundle

        Parameters
        ----------
        failure_surface : FailureSurface
            Instance of "FailureSurface" class. Must contain the attribute 
            "cross_sectional_area" that contains the cross-sectinonal area of the
            failure surface
        k : float, optional
            Wu/Waldron reinforcement orientation factor. The default is 1.0.

        Returns
        -------
        float
            peak root reinforcement.

        """
        # check cross-sectional area correctly defined
        if not isinstance(failure_surface, FailureSurface):
            TypeError('failure_surface must be intance of FailureSurface class')
        if not hasattr(failure_surface, 'cross_sectional_area'):
            AttributeError('failure_surface must contain attribute "cross_sectional_area"')
        # check k-value
        if not(isinstance(k, int) | isinstance(k, float)):
            raise TypeError('k must be scalar integer or float')
        # return
        return(k * self.peak_force() / failure_surface.cross_sectional_area)
    
    
    # reduction factor
    def reduction_factor(
            self
            ) -> float:
        """
        Calculate the ratio between bundle peak force and the sum of 
        individual fibre strengths. Function will thus return a value between
        0 and 1. '1' indicates all roots break simultaneously.

        Returns
        -------
        float
            reduction factor.

        """
        force_rbmw = self.peak_force()
        force_root = np.sum(self.roots.xsection * self.roots.tensile_strength)
        return(force_rbmw / force_root)
    
    # plot RBMw force as function of pullout displacement
    def plot(
            self,
            n: int = 251,
            stack: bool = False,
            peak: bool = True,
            fraction: int | float = 0.9,  # minimum fraction of roots broken in each diameter,
            labels: list | bool = False, 
            xlabel: chr = 'Pull-out displacement', 
            ylabel: chr = 'Total force in root bundle',
            xunit: chr = 'mm',
            yunit: chr = 'N'
            ): 
        """
        Show force-displacement plot for the RBMw model

        Parameters
        ----------
        n : int, optional
            Number of equally-spaced points to use to plot. 
        fraction : float, optional
            Plot until for every root, <fraction> of roots has broken
        xlabel, ylabel : str, optional
            x- and y-axis labels. Units will be added to this automatically
        xunit, yunit : str, optional
            displacement and force units to use on the axes. Results are 
            automatically converted before plotting
        peak : bool, optional
            plot the location of peak reinforcement using a scatter plot 
            marker

        Returns
        -------
        tuple
            tuple containing Matplotlib figure and axis objects

        """
        # calculate peak force and displacement
        peak_results = self.peak_force(full_output = True)
        # displacement to average root failure
        displacement_average = self.roots.tensile_strength / self.roots.elastic_modulus * self.roots.length
        displacement_max = (
            np.max(displacement_average) 
            * self.weibull_scale
            * (-np.log(1. - fraction)) ** (1. / self.weibull_shape)
        )
        # displacement range
        displacement = np.linspace(0, displacement_max, n)
        # calculate total forces
        force = self.force(displacement, total = True)
        # generate plot object
        fig, ax = plt.subplots()
        # convert values to magnitudes, for plotting
        peak_displacement_magnitude = peak_results['displacement'].to(xunit).magnitude
        peak_force_magnitude = peak_results['force'].to(yunit).magnitude
        displacement_magnitude = displacement.to(xunit).magnitude
        force_magnitude = force.to(yunit).magnitude
        # stack plot
        if stack is True:
            force_each = self.force(displacement, total = False)
            force_each_magnitude = force_each.to(yunit).magnitude
            ax.stackplot(displacement_magnitude, force_each_magnitude.transpose())
        # plot line
        ax.plot(displacement_magnitude, force_magnitude, '-', c = 'black')
        # plot peak reinforcement
        if peak is True:
            plt.scatter(peak_displacement_magnitude, peak_force_magnitude, c = 'black')
        # label text
        nroots = len(self.roots.diameter)
        if labels is True:
            labels = list(range(1, nroots + 1))
            plot_labels = True
        elif isinstance(labels, list):
            if len(labels) == nroots:
                plot_labels = True
            else:
                plot_labels = False
        else:
            plot_labels = False
        # add labels to plot
        if plot_labels is True:
            # label x-positions - at peaks of each individual root
            x_factor = self.weibull_scale * (1.0 / self.weibull_shape)**(1.0 / self.weibull_shape)
            labels_x_dimensional = (
                x_factor
                    * self.roots.tensile_strength
                    / self.roots.elastic_modulus
                    * self.roots.length
                )
            labels_x = labels_x_dimensional.to(xunit).magnitude
            # labels y-positions - halfway up each stacking instance
            labels_y_dimensional_all = self.force(labels_x_dimensional, total = False)
            labels_y_all = np.tril(labels_y_dimensional_all.to(yunit).magnitude)
            labels_y = np.sum(labels_y_all, axis = 1) -  0.5 * np.diag(labels_y_all)
            # add labels to plot
            for xi, yi, li in zip(labels_x, labels_y, labels):
                ax.annotate(
                    li, xy = (xi, yi), 
                    ha = 'center', 
                    va = 'center', 
                    bbox = dict(boxstyle = 'round', fc = 'white', alpha = 0.5),
                    fontsize = 'small'
                    )
        # axis limits
        ax.set_xlim(round_range(displacement_max.to(xunit).magnitude, limits = [0, None])['limits'])
        ax.set_ylim(round_range(peak_results['force'].to(yunit).magnitude, limits = [0., None])['limits'])
        # axis labels
        ax.set_xlabel(xlabel + ' [' + xunit + ']')
        ax.set_ylabel(ylabel + ' [' + yunit + ']')
        # return
        return(fig, ax)



##########################################
### BASE CLASS FOR DIRECT SHEAR MODELS ###
##########################################

class DirectShear():

    def __init__(
            self,
            roots: MultipleRoots,
            interface: Interface,
            soil_profile: SoilProfile,
            failure_surface: FailureSurface,
            distribution_factor: float | int = 0.5,
            **kwargs
    ):
        # check instances are of the correct class
        if not isinstance(roots, MultipleRoots):
            TypeError('roots must be instance of class MultipleRoots')
        if not isinstance(interface, Interface):
            TypeError('interface must be instance of class Interface')
        if not isinstance(soil_profile, SoilProfile):
            TypeError('soil_profile must be instance of class SoilProfile')
        if not isinstance(failure_surface, FailureSurface):
            TypeError('failure_surface must be instance of class FailureSurface')
        # assign input
        self.roots = roots
        self.interface = interface
        self.soil_profile = soil_profile
        self.failure_surface = failure_surface
        # distribution parameter
        if not(isinstance(distribution_factor, int) | isinstance(distribution_factor, float)):
            raise TypeError('distribution factor must be int or float')
        self.distribution_factor = distribution_factor
        # set root orientations (relative to failure surface)
        self._set_root_orientations()
        # set friction angle at failure surface
        self.failure_surface.tanphi = np.tan(
            soil_profile
            .get_soil(failure_surface.depth)
            .friction_angle
            .to('rad')
            )
        # kwargs
        for k, v in kwargs.items():
            setattr(self, k, v)
    
    def _set_root_orientations(
            self
            ) -> None:
        # function set 3-D root orientations **relative to** failure surface so that:
        # * local x = direction of shearing
        # * local y = perpendicular to x on shear plane
        # * local z = pointing downwards into the soil
        # orientations are defined in terms of 3-dimensional unit vectors
        #         
        # global coordinate system
        # * right-handed Cartesian coordinate system, with z-axis pointing down into the ground
        # * azimuth angle = angle from x-axis to projection of root vector on the x-y plane
        # * elevation angle = angle from z-axis to root vector
        #
        # failure surface
        # * assume angle is defined as angle in x-z plane, defined (positive) from x to z
        #
        # 
        # shape of root vector ('number of roots')
        roots_shape = self.roots.diameter.magnitude.shape
        # root orientations not defined - assume all perpendicular to failure surface
        if (not hasattr(self.roots, 'azimuth_angle')) & (not hasattr(self.roots, 'elevation_angle')):
            self.roots.orientation = np.stack((
                np.zeros(*roots_shape),
                np.zeros(*roots_shape),
                np.ones(*roots_shape)                    
                ), axis = -1)
        # (partial) angles provided -> rotate to local coordinate system
        else:
            if not hasattr(self.roots, 'azimuth_angle'):
                self.roots.azimuth_angle = np.zeros(*roots_shape) * units('deg')
            if not hasattr(self.roots, 'elevation_angle'):
                self.roots.elevation_angle = np.zeros(*roots_shape) * units('deg')
            # get global root orientations
            root_orientation_global = np.stack((
                np.cos(self.roots.azimuth_angle.magnitude) 
                * np.sin(self.roots.elevation_angle.magnitude),
                np.sin(self.roots.azimuth_angle.magnitude) 
                * np.sin(self.roots.elevation_angle.magnitude),
                np.cos(self.roots.elevation_angle.magnitude)
            ), axis = -1)
            # rotate to local coordinate system and set unit vectors
            if hasattr(self.failure_surface, 'orientation'):
                axisangle = np.array([0.0, -self.failure_surface.orientation.to('rad'), 0.0])
            else:
                axisangle = np.array([0.0, 0.0, 0.0])
            self.roots.orientation = axisangle_rotate(root_orientation_global, axisangle)

    def _get_orientation_parameters(
            self,
            displacement: Quantity,
            shear_zone_thickness: Quantity,
            jac: bool = False
    ):
        # vector components of initial root orientation in shear zone
        v0x = (
            shear_zone_thickness
            * self.roots.orientation[..., 0]
            / self.roots.orientation[..., 2]
            )
        v0y = (
            shear_zone_thickness
            * self.roots.orientation[..., 1]
            / self.roots.orientation[..., 2]
        )
        v0z = shear_zone_thickness * np.ones_like(v0x)
        # length in shear zone
        if shear_zone_thickness.magnitude >= 0.0:
            L0 = shear_zone_thickness / self.roots.orientation[..., 2]
            L = np.sqrt((v0x + displacement)**2 + v0y**2 + v0z**2)
        else:
            L0 = 0.0 * shear_zone_thickness * self.roots.orientation[..., 2]
            L = displacement * np.ones_like(v0x)
        # pullout displacement
        up = self.distribution_factor * (L - L0)
        # orientation factor
        k = ((v0x + displacement) + (v0z * self.failure_surface.tanphi)) / L
        # derivatives
        if jac is False:
            dup_ddisplacement = None
            dup_dshearzonethickness = None
            dk_ddisplacement = None
            dk_dshearzonethickness = None
        else:
            dv0x_dshearzonethickness = self.roots.orientation[..., 0] / self.roots.orientation[..., 2]
            dv0y_dshearzonethickness = self.roots.orientation[..., 1] / self.roots.orientation[..., 2]
            dv0z_dshearzonethickness = np.ones_like(v0z)
            if shear_zone_thickness.magnitude >= 0.0:
                dL0_dshearzonethickness = 1.0 / self.roots.orientation[..., 2]
                dL_ddisplacement = (v0x + displacement) / L
                dL_dv0x = (v0x + displacement) / L
                dL_dv0y = v0y / L
                dL_dv0z = v0z / L
            else:
                dL0_dshearzonethickness = 0.0 * self.roots.orientation[..., 2]
                dL_ddisplacement = np.ones_like(v0z)
                dL_dv0x = np.ones_like(v0z)
                dL_dv0y = np.ones_like(v0z)
                dL_dv0z = np.ones_like(v0z)
            dup_ddisplacement = self.distribution_factor * dL_ddisplacement
            dL_dshearzonethickness = (
                dL_dv0x * dv0x_dshearzonethickness
                + dL_dv0y * dv0y_dshearzonethickness
                + dL_dv0z * dv0z_dshearzonethickness
                )
            dup_dshearzonethickness = self.distribution_factor * (dL_dshearzonethickness - dL0_dshearzonethickness)
            dk_ddisplacement = (
                1.0 / L
                - k / L * dL_ddisplacement
            )
            dk_dshearzonethickness = (
                (dv0x_dshearzonethickness + dv0z_dshearzonethickness * self.failure_surface.tanphi) / L
                - k / L * dL_dshearzonethickness
            )
        return(
            up,
            k,
            dup_ddisplacement, 
            dup_dshearzonethickness,
            dk_ddisplacement,
            dk_dshearzonethickness
        )



###########################
### WALDRON-TYPE MODELS ###
###########################

# Waldron class
class Waldron(DirectShear):

    # initiate model
    def __init__(
            self,
            roots: MultipleRoots,
            interface: Interface,
            soil_profile: SoilProfile,
            failure_surface: FailureSurface,
            slipping: bool = True,
            breakage: bool = True,
            elastoplastic: bool = False,
            weibull_shape: float | int | None = None,
            **kwargs
    ): 
        # call __init__ from parent class
        super().__init__(roots, interface, soil_profile, failure_surface, **kwargs)
        # set flags for analysis type (allowing for slippage, breakage and/or elastoplasticity)
        self.slipping = slipping
        self.breakage = breakage
        self.elastoplastic = elastoplastic
        # check weibull shape
        if isinstance(weibull_shape, int) | isinstance(weibull_shape, float):
            if weibull_shape <= 0.0:
                raise ValueError('weibull_shape must exceed zero')
            elif np.isinf(weibull_shape):
                raise ValueError('weibull_shape must have finite value. Set to None for sudden breakages')
        else:
            if weibull_shape is not None:
                raise TypeError('weibull_shape must be an int, float or None')
        # set correct pullout object, depending on cases (slipping, breakage etc)
        if slipping is True:
            if breakage is True:
                if elastoplastic is True:
                    self.pullout = PulloutEmbeddedElastoplasticBreakageSlipping(
                        roots, interface, weibull_shape = weibull_shape)
                else:
                    self.pullout = PulloutEmbeddedElasticBreakageSlipping(
                        roots, interface, weibull_shape = weibull_shape)
            else:
                if elastoplastic is True:
                    self.pullout = PulloutEmbeddedElastoplasticSlipping(
                        roots, interface)
                else:
                    self.pullout = PulloutEmbeddedElasticSlipping(
                        roots, interface)
        else:
            if breakage is True:
                if elastoplastic is True:
                    self.pullout = PulloutEmbeddedElastoplasticBreakage(
                        roots, interface, weibull_shape = weibull_shape)
                else:
                    self.pullout = PulloutEmbeddedElasticBreakage(
                        roots, interface, weibull_shape = weibull_shape)
            else:
                if elastoplastic is True:
                    self.pullout = PulloutEmbeddedElastoplastic(
                        roots, interface)
                else:
                    self.pullout = PulloutEmbeddedElastic(
                        roots, interface)

    # calculate root reinforcement at given displacement step
    def reinforcement(
            self,
            displacement: float | int | Quantity,
            displacement_unit: str = 'm',
            total: bool = True,
            jac: bool = False,
            sign: int | float = 1.0
            ) -> Quantity:
        # set displacement value with units - and make array (if not already so)
        if isinstance(displacement, Quantity):
            if displacement.dimensionality != units('m').dimensionality:
                raise DimensionalityError('dimensionality of displacement must be length')
            if not np.isscalar(displacement.magnitude):
               displacement = Quantity.from_list([displacement])
        elif isinstance(displacement, int) | isinstance(displacement, float):
            warnings.warn('Unit of displacement not defined. Assumed as ' + displacement_unit)
            displacement = np.array([displacement]) * units(displacement_unit)
        elif isintance(displacement, list):
            warnings.warn('Unit of displacement not defined. Assumed as ' + displacement_unit)
            displacement = np.array(displacement) * units(displacement_unit)
        elif isinstance(displacement, np.ndarray):
            warnings.warn('Unit of displacement not defined. Assumed as ' + displacement_unit)
            displacement = displacement * units(displacement_unit)
        else:
            raise TypeError('input type for displacement not recognised')
        # relative cross-sectional area of each root
        xsection_rel = self.roots.xsection.magnitude / np.sum(self.roots.xsection.magnitude)
        # loop through all displacement steps
        cr_all = []
        dcr_dus_all = []
        xsection_fractions_all = []
        for disp in displacement:
            # pullout displacement (up) and orientation factors (k)
            up, k, dup_dus, _, dk_dus, _ = self._get_orientation_parameters(
                disp,
                self.failure_surface.shear_zone_thickness,
                jac = jac
            )
            # pullout force (Tp), survival fraction (S) and behaviour type index (b)
            Tp, dTp_dup, S, b = self.pullout.force(up, jac = jac)
            # reinforcement
            cr = sign * np.sum(k * Tp) / self.failure_surface.cross_sectional_area
            # fraction of root cross-sectional area for each behaviour types
            xsection_fractions = np.bincount(
                b, 
                weights = S * xsection_rel,
                minlength = len(self.pullout.behaviour_types)
                )
            # return jacobian if requested
            if jac is True:
                dcr_dus = sign * (
                    np.sum(dk_dus * Tp + k * dTp_dup * dup_dus) 
                    / self.failure_surface.cross_sectional_area
                    )
            else:
                dcr_dus = None
            # append
            cr_all.append(cr)
            dcr_dus_all.append(dcr_dus)
            xsection_fractions_all.append(xsection_fractions)
        # create output arrays
        cr_out = Quantity.from_list(cr_all).squeeze()
        dcr_dus_out = Quantity.from_list(dcr_dus_all).squeeze() if dcr_dus_all[0] is not None else None
        xsection_fractions_out = np.array(xsection_fractions_all).squeeze()
        # return
        return(cr_out, dcr_dus_out, xsection_fractions_out)

    # find soil shear displacement at peak force of each root
    def _get_displacement_root_peak(self):
        # get force at failure in each root
        if self.breakage is True:
            force_breakage = self.roots.xsection * self.roots.tensile_strength
        if self.slipping is True:
            force_slipping = self.roots.length * self.roots.circumference * self.interface.shear_strength
        # select limiting case
        if self.breakage is True:
            if self.slipping is True:
                force = np.minimum(force_breakage, force_slipping)
            else:
                force = force_breakage
        else:
            if self.slipping is True:
                force = force_slipping
            else:
                return(None)
        # get index of correct behaviour
        if self.elastoplastic is False:
            i = np.flatnonzero(self.pullout.behaviour_types == 'Anchored, elastic')[0]
            pullout_displacement = (
                self.pullout.coefficients[0][..., i] * force**2
                + self.pullout.coefficients[1][..., i] * force
                + self.pullout.coefficients[2][..., i]
                )
        else:
            i = np.flatnonzero(self.pullout.behaviour_types == 'Anchored, plastic')[0]
            print('Not yet implemented')
        # calculate shear displacement at failure
        elongation = pullout_displacement / self.distribution_factor
        vx = self.roots.orientation[..., 0]
        vy = self.roots.orientation[..., 1]
        vz = self.roots.orientation[..., 2]
        h = self.failure_surface.shear_zone_thickness
        shear_displacement = (
            np.sqrt((elongation + h / vz)**2 - h**2 * (1.0 + vy**2 / vz**2))
            - h * vx / vz
        )
        # return
        return(shear_displacement)

    # find peak reinforcement
    def peak_reinforcement(self):
        # no root breakage or slipping -> infinite reinforcement
        if self.breakage is False and self.slipping is False:
            warnings.warn('No breakage or slipping - peak reinforcement is infinite!')
            return(
                np.inf * units('m'),
                np.inf * units('kPa')
                )
        # get range of displacements, and get reinforcement for each
        us_all = self._get_displacement_root_peak()
        us_start_unit = 'mm'
        us_min = np.min(us_all).to(us_start_unit).magnitude
        us_max = np.max(us_all).to(us_start_unit).magnitude
        # optimize
        def fun(x):
            y, _, _ = self.reinforcement(
                x,
                displacement_unit = us_start_unit,
                jac = False,
                sign = -1.0
                )
            return(y.magnitude)
        sol = differential_evolution(
            fun,
            bounds = [(us_min, us_max)]
            )
        # peak
        us_peak = sol.x[0] * units(us_start_unit)
        cr_peak, _, _ = self.reinforcement(us_peak, jac = False)
        # return
        return(us_peak, cr_peak)

    # plot shear displacement versus reinforcement 
    def plot(
            self,
            n: int = 251,
            xunit: str = 'mm',
            yunit: str = 'kPa',
            stack = False,
            peak: bool = True,
            labels = True,
            xlabel: str = 'Shear displacement',
            ylabel: str = 'Reinforcement',
            margin: int | float = 0.05          
            ):
        # no root breakage or slipping -> infinite reinforcement
        if self.breakage is False and self.slipping is False:
            us_peak = 100.0 * units('mm')
        else:
            us_peak = np.max(self._get_displacement_root_peak())
        us = np.linspace(0.0 * us_peak, us_peak * (1.0 + margin), n)
        # total reinforcement, per root, for each displacement step
        cr_i = [self.reinforcement(i, total = False)[0] for i in us]
        cr_magnitude = np.stack([i.to(yunit).magnitude for i in cr_i], axis = -1)
        cr = np.sum(cr_magnitude, axis = 0)
        # plot trace
        fig, ax  = plt.subplots()
        ax.plot(
            us.to(xunit).magnitude,
            cr,
            c = 'black'
            )
        # stack plot
        if stack is True:
            ax.stackplot(
                us.to(xunit).magnitude,
                cr_magnitude
            )
        # label text
        nroots = len(self.roots.diameter)
        if labels is True:
            labels = list(range(1, nroots + 1))
            plot_labels = True
        elif isinstance(labels, list):
            if len(labels) == nroots:
                plot_labels = True
            else:
                plot_labels = False
        else:
            plot_labels = False
        # add labels to plot
        if plot_labels is True:
            # label x-positions - at peaks of each individual root
            labels_x = us[int(0.5 * n)]
            # labels y-positions - halfway up each stacking instance
            labels_y_tmp = self.reinforcement(labels_x, total = False)[0].to(yunit).magnitude
            labels_y = np.cumsum(labels_y_tmp) - 0.5 * labels_y_tmp
            # add labels to plot
            for yi, li in zip(labels_y, labels):
                ax.annotate(
                    li, 
                    xy = (labels_x.to(xunit).magnitude, yi), 
                    ha = 'center', 
                    va = 'center', 
                    bbox = dict(boxstyle = 'round', fc = 'white', alpha = 0.5),
                    fontsize = 'small'
                    )
        # plot peak
        if peak is True:
            us_peak, cr_peak = self.peak_reinforcement()
            plt.scatter(
                us_peak.to(xunit).magnitude,
                cr_peak.to(yunit).magnitude,
                c = 'black'
                )
        # set labels
        ax.set_xlabel(xlabel + ' [' + str(xunit) + ']')
        ax.set_ylabel(ylabel + ' [' + str(yunit) + ']')
        # return
        return(fig, ax)
